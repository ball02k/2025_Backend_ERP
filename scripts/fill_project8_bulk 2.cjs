#!/usr/bin/env node
/* eslint-disable no-console */
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

function yyyymm(n=0){
  const d = new Date();
  d.setMonth(d.getMonth()+n);
  return d.toISOString().slice(0,7);
}

async function main(){
  const tenantId = process.env.TENANT_DEFAULT || 'demo';
  const projectId = Number(process.env.PROJECT_ID || 8);

  const project = await prisma.project.findFirst({ where: { tenantId, id: projectId } });
  if (!project) { console.error(`Project ${projectId} not found`); process.exit(1); }

  // Ensure supplier
  let supplier = await prisma.supplier.findFirst({ where: { tenantId, name: 'Demo Supplier Ltd' } });
  if (!supplier) supplier = await prisma.supplier.create({ data: { tenantId, name: 'Demo Supplier Ltd', status: 'active' } });

  // Ensure task statuses (tenantId nullable; use 0 as in schema)
  const statusKeys = ['Open','In Progress','Done'];
  const taskStatusIds = {};
  for (const key of statusKeys) {
    const up = await prisma.taskStatus.upsert({ where: { tenantId_key: { tenantId: 0, key } }, update: {}, create: { tenantId: 0, key, label: key } });
    taskStatusIds[key] = up.id;
  }

  // Ensure packages
  const pkgMain = await prisma.package.findFirst({ where: { projectId, name: 'Main Works' } })
    || await prisma.package.create({ data: { projectId, name: 'Main Works', scope: 'Main build works', status: 'Draft' } });
  const pkgEnable = await prisma.package.findFirst({ where: { projectId, name: 'Enabling Works' } })
    || await prisma.package.create({ data: { projectId, name: 'Enabling Works', scope: 'Site enabling and prelims', status: 'Draft' } });

  // Contract for Main Works
  let contract = await prisma.contract.findFirst({ where: { projectId, packageId: pkgMain.id } });
  if (!contract) {
    contract = await prisma.contract.create({ data: { projectId, packageId: pkgMain.id, supplierId: supplier.id, title: 'Main Works Contract', contractNumber: 'CNT-MW-001', value: 60000, originalValue: 60000, status: 'Pending', startDate: new Date() } });
  }

  // Budget lines (add a few extra)
  const blCodes = [
    ['BL-003','Superstructure', 40000],
    ['BL-004','Substructure', 30000],
    ['BL-005','MEP Allowance', 20000],
    ['BL-006','Prelims', 15000],
  ];
  for (const [code, name, planned] of blCodes) {
    const ex = await prisma.budgetLine.findFirst({ where: { tenantId, projectId, code } });
    if (!ex) await prisma.budgetLine.create({ data: { tenantId, projectId, code, planned, amount: planned, description: name } });
  }

  // Tasks: 20
  for (let i=1;i<=20;i++){
    const title = `Task #${i}`;
    const ex = await prisma.task.findFirst({ where: { tenantId, projectId, title } });
    if (ex) continue;
    const statusKey = i%3===0 ? 'Done' : (i%2===0 ? 'In Progress' : 'Open');
    await prisma.task.create({ data: {
      tenantId, projectId, title,
      description: `Autogenerated task ${i}`,
      dueDate: new Date(Date.now() + i*2*86400000),
      status: statusKey, statusId: taskStatusIds[statusKey],
    }});
  }

  // RFIs: 10
  for (let i=1;i<=10;i++){
    const rfiNumber = `RFI-${projectId}-${String(i).padStart(3,'0')}`;
    const ex = await prisma.rfi.findFirst({ where: { tenantId, rfiNumber } });
    if (ex) continue;
    await prisma.rfi.create({ data: { tenantId, projectId, rfiNumber, subject: `RFI subject ${i}`, question: `Please clarify spec item ${i}.`, status: i%2?'open':'closed', priority: 'med', dueDate: new Date(Date.now()+i*86400000) } });
  }

  // QA: 5 records with items
  for (let i=1;i<=5;i++){
    const title = `QA Check ${i}`;
    const ex = await prisma.qaRecord.findFirst({ where: { tenantId, projectId, title } });
    if (ex) continue;
    const rec = await prisma.qaRecord.create({ data: { tenantId, projectId, type: 'Inspection', title, description: `QA inspection ${i}`, status: 'open' } });
    await prisma.qaItem.create({ data: { tenantId, qaRecordId: rec.id, item: `Checklist item A${i}`, result: 'open' } });
    await prisma.qaItem.create({ data: { tenantId, qaRecordId: rec.id, item: `Checklist item B${i}`, result: 'open' } });
  }

  // H&S: 5 events
  const hsTypes = ['Incident','Near Miss','Observation'];
  for (let i=1;i<=5;i++){
    const title = `HS Event ${i}`;
    const ex = await prisma.hsEvent.findFirst({ where: { tenantId, projectId, title } });
    if (ex) continue;
    await prisma.hsEvent.create({ data: { tenantId, projectId, type: hsTypes[i%hsTypes.length], title, description: `HS description ${i}`, eventDate: new Date(), status: 'open', severity: i%2?'low':'medium' } });
  }

  // Carbon: 5 entries
  for (let i=1;i<=5;i++){
    await prisma.carbonEntry.create({ data: { tenantId, projectId, scope: '3', category: 'Transport', activityDate: new Date(), quantity: i*0.5, unit: 't', emissionFactor: 300, factorUnit: 'kgCO2e/t', calculatedKgCO2e: i*150, supplierId: supplier.id, notes: `Delivery batch ${i}` } }).catch(()=>{});
  }

  // POs: 5 additional
  for (let i=2;i<=6;i++){
    const code = `PO-000${i}`;
    const ex = await prisma.purchaseOrder.findFirst({ where: { tenantId, projectId, code } });
    if (ex) continue;
    await prisma.purchaseOrder.create({ data: {
      tenantId, projectId, code, supplier: supplier.name, supplierId: supplier.id, status: 'Open', total: 1000*i,
      lines: { create: [ { tenantId, item: `Material batch ${i}`, qty: i*10, unit: 'ea', unitCost: 10, lineTotal: i*100 } ] },
      deliveries: { create: [ { tenantId, expectedAt: new Date(Date.now()+i*3*86400000), note: `Delivery ${i}` } ] },
    } });
  }

  // Invoices: 5 additional
  for (let i=1;i<=5;i++){
    const number = `INV-${new Date().toISOString().slice(0,10).replace(/-/g,'')}-MW-${i}`;
    const ex = await prisma.invoice.findFirst({ where: { tenantId, projectId, number } });
    if (ex) continue;
    await prisma.invoice.create({ data: { tenantId, projectId, supplierId: supplier.id, number, issueDate: new Date(), dueDate: new Date(Date.now()+14*86400000), net: 2000*i, vat: 400*i, gross: 2400*i, status: 'Open', source: 'seed', packageId: pkgMain.id, contractId: contract.id } });
  }

  // Variations: 5 (no contractId due to Int mismatch)
  for (let i=2;i<=6;i++){
    const title = `Doorway change ${i}`;
    const ex = await prisma.variation.findFirst({ where: { tenantId, projectId, title } });
    if (ex) continue;
    await prisma.variation.create({ data: { tenantId, projectId, packageId: pkgMain.id, title, description: `Change request ${i}`, contractType: 'JCT', type: 'Change', status: i%2?'Submitted':'Approved', value: 1000*i, amount: 1000*i, costImpact: 900*i, timeImpactDays: i%3, lines: { create: [{ tenantId, description: `Line ${i}`, qty: 1, rate: 1000*i, value: 1000*i }] } } });
  }

  // Forecasts: current and previous 5 months
  for (let i=0;i<6;i++){
    const period = yyyymm(-i);
    await prisma.forecast.upsert({ where: { tenantId_projectId_period: { tenantId, projectId, period } }, update: { amount: 40000 - i*2500 }, create: { tenantId, projectId, period, amount: 40000 - i*2500 } });
  }

  // AfPs: 3 sequential
  const baseSeq = await prisma.applicationForPayment.count({ where: { tenantId } });
  for (let i=1;i<=3;i++){
    const applicationNo = `AFP-${new Date().getFullYear()}-${String(baseSeq+i).padStart(5,'0')}`;
    const ex = await prisma.applicationForPayment.findFirst({ where: { tenantId, applicationNo } });
    if (ex) continue;
    await prisma.applicationForPayment.create({ data: {
      tenantId, projectId, supplierId: supplier.id, contractId: contract.id,
      applicationNo,
      applicationDate: new Date(), periodStart: new Date(new Date().getFullYear(), new Date().getMonth(), 1), periodEnd: new Date(),
      currency: 'GBP', grossToDate: 20000+i*1000, variationsValue: 2500, prelimsValue: 1500, retentionValue: 800, mosValue: 0, offsiteValue: 0, deductionsValue: 0, netClaimed: 18000+i*900,
      status: i===3?'payment_notice':'submitted',
    } });
  }

  console.log('Bulk MVP data seeded for project', projectId);
}

main().then(()=>process.exit(0)).catch((e)=>{ console.error(e); process.exit(1); });

