const express = require('express');
const router = express.Router();
const { prisma } = require('../utils/prisma.cjs');
const { requireAuth } = require('../lib/auth.cjs');
const { sendTenderInvitation } = require('../services/email.service.cjs');

router.use(requireAuth);

const tenantIdOf = (req) => req.user && req.user.tenantId;

// ==========================================
// TENDER INVITATIONS
// ==========================================

// GET /api/tenders/:tenderId/invitations - List invitations for a tender
router.get('/:tenderId/invitations', async (req, res, next) => {
  try {
    const tenantId = tenantIdOf(req);
    const requestId = Number(req.params.tenderId);

    // Verify tender exists
    const tender = await prisma.request.findFirst({
      where: { id: requestId, tenantId }
    });

    if (!tender) {
      return res.status(404).json({ error: 'Tender not found' });
    }

    // Get invitations with supplier details
    const invitations = await prisma.tenderInvitation.findMany({
      where: {
        tenantId,
        requestId
      },
      include: {
        supplier: {
          select: {
            id: true,
            name: true,
            email: true,
            phone: true
          }
        },
        invitedByUser: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      },
      orderBy: { invitedAt: 'desc' }
    });

    const items = invitations.map(inv => ({
      id: inv.id,
      supplierId: inv.supplierId,
      supplierName: inv.supplier?.name,
      supplierEmail: inv.supplier?.email,
      supplierPhone: inv.supplier?.phone,
      invitedAt: inv.invitedAt,
      invitedBy: inv.invitedByUser?.name,
      viewedAt: inv.viewedAt,
      viewCount: inv.viewCount,
      status: inv.status,
      declinedAt: inv.declinedAt,
      declineReason: inv.declineReason,
      siteVisitBooked: inv.siteVisitBooked,
      siteVisitSlot: inv.siteVisitSlot,
      accessToken: inv.accessToken,
      documentsDownloaded: inv.documentsDownloaded
    }));

    res.json({ items, total: items.length });
  } catch (e) {
    console.error('Error listing tender invitations:', e);
    next(e);
  }
});

// POST /api/tenders/:tenderId/invitations - Send invitations to suppliers
router.post('/:tenderId/invitations', async (req, res, next) => {
  try {
    const tenantId = tenantIdOf(req);
    const requestId = Number(req.params.tenderId);
    const { supplierIds } = req.body;

    if (!Array.isArray(supplierIds) || supplierIds.length === 0) {
      return res.status(400).json({ error: 'supplierIds array is required' });
    }

    // Verify tender exists
    const tender = await prisma.request.findFirst({
      where: { id: requestId, tenantId },
      include: {
        package: {
          select: {
            id: true,
            name: true,
            project: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }
      }
    });

    if (!tender) {
      return res.status(404).json({ error: 'Tender not found' });
    }

    // Get suppliers
    const suppliers = await prisma.supplier.findMany({
      where: {
        id: { in: supplierIds.map(Number) },
        tenantId
      },
      select: {
        id: true,
        name: true,
        email: true,
        phone: true
      }
    });

    if (suppliers.length === 0) {
      return res.status(400).json({ error: 'No valid suppliers found' });
    }

    // Check for existing invitations
    const existingInvitations = await prisma.tenderInvitation.findMany({
      where: {
        tenantId,
        requestId,
        supplierId: { in: suppliers.map(s => s.id) }
      },
      select: { supplierId: true }
    });

    const existingSupplierIds = new Set(existingInvitations.map(inv => inv.supplierId));
    const newSuppliers = suppliers.filter(s => !existingSupplierIds.has(s.id));

    if (newSuppliers.length === 0) {
      return res.status(400).json({
        error: 'All selected suppliers have already been invited',
        alreadyInvited: suppliers.length
      });
    }

    // Create invitations
    const createdInvitations = await Promise.all(
      newSuppliers.map(async (supplier) => {
        const invitation = await prisma.tenderInvitation.create({
          data: {
            tenantId,
            requestId,
            supplierId: supplier.id,
            invitedBy: req.user?.id || null,
            status: 'invited'
            // accessToken is auto-generated by schema default
          }
        });

        // Send email notification
        try {
          await sendTenderInvitation({
            supplier,
            tender,
            invitation,
            projectName: tender.package?.project?.name || 'Project',
            packageName: tender.package?.name || 'Package'
          });
        } catch (emailError) {
          console.error(`Failed to send email to ${supplier.email}:`, emailError);
          // Continue even if email fails
        }

        // Create timeline event
        await prisma.tenderTimelineEvent.create({
          data: {
            tenantId,
            requestId,
            eventType: 'invitation_sent',
            eventDate: new Date(),
            description: `Invitation sent to ${supplier.name}`,
            actorId: req.user?.id || null,
            metadata: {
              supplierId: supplier.id,
              supplierName: supplier.name
            }
          }
        }).catch(() => {
          // Timeline is optional, don't fail
        });

        return {
          id: invitation.id,
          supplierId: supplier.id,
          supplierName: supplier.name,
          supplierEmail: supplier.email,
          invitedAt: invitation.invitedAt,
          accessToken: invitation.accessToken,
          status: invitation.status
        };
      })
    );

    res.status(201).json({
      items: createdInvitations,
      total: createdInvitations.length,
      skipped: suppliers.length - newSuppliers.length
    });
  } catch (e) {
    console.error('Error creating tender invitations:', e);
    next(e);
  }
});

// GET /api/tenders/:tenderId/invitations/:invitationId - Get specific invitation
router.get('/:tenderId/invitations/:invitationId', async (req, res, next) => {
  try {
    const tenantId = tenantIdOf(req);
    const requestId = Number(req.params.tenderId);
    const invitationId = Number(req.params.invitationId);

    const invitation = await prisma.tenderInvitation.findFirst({
      where: {
        id: invitationId,
        requestId,
        tenantId
      },
      include: {
        supplier: true,
        request: {
          include: {
            package: {
              include: {
                project: true
              }
            }
          }
        }
      }
    });

    if (!invitation) {
      return res.status(404).json({ error: 'Invitation not found' });
    }

    res.json(invitation);
  } catch (e) {
    console.error('Error fetching invitation:', e);
    next(e);
  }
});

// DELETE /api/tenders/:tenderId/invitations/:invitationId - Cancel invitation
router.delete('/:tenderId/invitations/:invitationId', async (req, res, next) => {
  try {
    const tenantId = tenantIdOf(req);
    const requestId = Number(req.params.tenderId);
    const invitationId = Number(req.params.invitationId);

    const invitation = await prisma.tenderInvitation.findFirst({
      where: {
        id: invitationId,
        requestId,
        tenantId
      }
    });

    if (!invitation) {
      return res.status(404).json({ error: 'Invitation not found' });
    }

    // Soft delete by updating status
    await prisma.tenderInvitation.update({
      where: { id: invitationId },
      data: {
        status: 'cancelled'
      }
    });

    res.status(204).end();
  } catch (e) {
    console.error('Error cancelling invitation:', e);
    next(e);
  }
});

// PUT /api/tenders/:tenderId/invitations/:invitationId/track-view - Track invitation view
router.put('/:tenderId/invitations/:invitationId/track-view', async (req, res, next) => {
  try {
    const tenantId = tenantIdOf(req);
    const requestId = Number(req.params.tenderId);
    const invitationId = Number(req.params.invitationId);

    const invitation = await prisma.tenderInvitation.findFirst({
      where: {
        id: invitationId,
        requestId,
        tenantId
      }
    });

    if (!invitation) {
      return res.status(404).json({ error: 'Invitation not found' });
    }

    // Update view tracking
    const updated = await prisma.tenderInvitation.update({
      where: { id: invitationId },
      data: {
        viewedAt: invitation.viewedAt || new Date(),
        viewCount: { increment: 1 },
        status: invitation.status === 'invited' ? 'viewed' : invitation.status
      }
    });

    res.json(updated);
  } catch (e) {
    console.error('Error tracking invitation view:', e);
    next(e);
  }
});

// ==========================================
// QUICK INVITE - Add supplier by email on-the-fly
// ==========================================

// POST /api/tenders/:tenderId/quick-invite - Invite supplier by email (creates supplier if needed)
router.post('/:tenderId/quick-invite', async (req, res, next) => {
  try {
    const tenantId = tenantIdOf(req);
    const requestId = Number(req.params.tenderId);
    const { email, name, phone, trade } = req.body;

    // Validate inputs
    if (!email || !name) {
      return res.status(400).json({ error: 'Email and name are required' });
    }

    // Verify tender exists
    const tender = await prisma.request.findFirst({
      where: { id: requestId, tenantId },
      include: {
        package: {
          select: {
            id: true,
            name: true,
            project: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }
      }
    });

    if (!tender) {
      return res.status(404).json({ error: 'Tender not found' });
    }

    // Check if supplier already exists by email
    let supplier = await prisma.supplier.findFirst({
      where: {
        tenantId,
        email: email.trim().toLowerCase()
      }
    });

    // If supplier doesn't exist, create them
    if (!supplier) {
      supplier = await prisma.supplier.create({
        data: {
          tenantId,
          name: name.trim(),
          email: email.trim().toLowerCase(),
          phone: phone?.trim() || null,
          status: 'pending', // Mark as pending until they respond
        }
      });

      // Add capability tag if trade provided
      if (trade) {
        await prisma.supplierCapability.create({
          data: {
            tenantId,
            supplierId: supplier.id,
            tag: `category:${trade.trim()}`
          }
        }).catch(() => {
          // Capability is optional, don't fail
        });
      }

      console.log(`✓ Created new supplier: ${supplier.name} (${supplier.email})`);
    }

    // Check if already invited
    const existingInvitation = await prisma.tenderInvitation.findFirst({
      where: {
        tenantId,
        requestId,
        supplierId: supplier.id
      }
    });

    if (existingInvitation) {
      return res.status(400).json({
        error: 'Supplier already invited to this tender',
        supplier: {
          id: supplier.id,
          name: supplier.name,
          email: supplier.email
        },
        invitation: {
          id: existingInvitation.id,
          status: existingInvitation.status,
          invitedAt: existingInvitation.invitedAt
        }
      });
    }

    // Create invitation
    const invitation = await prisma.tenderInvitation.create({
      data: {
        tenantId,
        requestId,
        supplierId: supplier.id,
        invitedBy: req.user?.id || null,
        status: 'invited'
      }
    });

    // Send email notification
    try {
      await sendTenderInvitation({
        supplier,
        tender,
        invitation,
        projectName: tender.package?.project?.name || 'Project',
        packageName: tender.package?.name || 'Package'
      });
      console.log(`✓ Email sent to ${supplier.email}`);
    } catch (emailError) {
      console.error(`Failed to send email to ${supplier.email}:`, emailError);
      // Continue even if email fails
    }

    // Create timeline event
    await prisma.tenderTimelineEvent.create({
      data: {
        tenantId,
        requestId,
        eventType: 'invitation_sent',
        eventDate: new Date(),
        description: `Quick invite sent to ${supplier.name} (${supplier.email})`,
        actorId: req.user?.id || null,
        metadata: {
          supplierId: supplier.id,
          supplierName: supplier.name,
          quickInvite: true,
          newSupplier: !existingInvitation
        }
      }
    }).catch(() => {
      // Timeline is optional, don't fail
    });

    res.status(201).json({
      success: true,
      message: supplier.id ? 'Supplier invited successfully' : 'Supplier created and invited',
      supplier: {
        id: supplier.id,
        name: supplier.name,
        email: supplier.email,
        phone: supplier.phone,
        status: supplier.status,
        isNew: !existingInvitation
      },
      invitation: {
        id: invitation.id,
        supplierId: supplier.id,
        invitedAt: invitation.invitedAt,
        accessToken: invitation.accessToken,
        status: invitation.status
      }
    });
  } catch (e) {
    console.error('Error with quick invite:', e);
    next(e);
  }
});

module.exports = router;
